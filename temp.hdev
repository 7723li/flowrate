<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.3.0">
<procedure name="main">
<interface/>
<body>
<c>***************************************新型防抖骗术BEGIN***************************************</c>
<c>* 用首帧建立ROI</c>
<l>read_image(ImageSrc, 'C:/Users/7723/Desktop/codes/halcon/PicAndTemplate/V1001559/0')</l>
<c></c>
<l>get_image_size(ImageSrc, Width, Height)</l>
<c></c>
<l>count_channels(ImageSrc, Channels)</l>
<l>if(Channels == 3)</l>
<l>    rgb1_to_gray(ImageSrc, ImageSrc)</l>
<l>endif</l>
<c></c>
<l>gauss_filter(ImageSrc, ImageGauss, 7)</l>
<c></c>
<c>* 寻找血管线 均值滤波+动态阈值</c>
<l>mean_image(ImageGauss, ImageMean, 31, 31)</l>
<l>dyn_threshold(ImageGauss, ImageMean, RegionDynThresh, 5, 'dark')</l>
<c></c>
<c>* 开运算 先将粘连的分开</c>
<l>opening_circle(RegionDynThresh, RegionOpening, 1)</l>
<c></c>
<c>* 筛选</c>
<l>connection(RegionOpening, ConnectedRegions)</l>
<l>select_shape(ConnectedRegions, SelectedRegions, 'area', 'and', 400, 99999)</l>
<c></c>
<c>* 闭运算 加回开运算时损失的面积 得到最终的ROI集合</c>
<l>closing_circle(SelectedRegions, RegionDilation, 1)</l>
<c></c>
<c>* 输出完整的血管图 调试用</c>
<l>union1(SelectedRegions, RegionUnion)</l>
<l>boundary(RegionUnion, RegionUnionBorder, 'inner')</l>
<c></c>
<l>gen_image_const(ImageVesselR, 'byte', Width, Height)</l>
<l>gen_image_const(ImageVesselG, 'byte', Width, Height)</l>
<l>gen_image_const(ImageVesselB, 'byte', Width, Height)</l>
<c></c>
<l>overpaint_region(ImageVesselR, RegionUnionBorder, 255, 'fill')</l>
<l>overpaint_region(ImageVesselG, RegionUnionBorder, 0, 'fill')</l>
<l>overpaint_region(ImageVesselB, RegionUnionBorder, 0, 'fill')</l>
<c></c>
<l>compose3(ImageVesselR, ImageVesselG, ImageVesselB, ImageVesselRGB)</l>
<c></c>
<l>write_image(ImageVesselRGB, 'png', 0, 'C:/Users/7723/Desktop/codes/halcon/PicAndTemplate/V1001559/1_CellTrack/_vessel.png')</l>
<c></c>
<c>* 调试显示</c>
<l>dev_clear_window()</l>
<l>dev_display(ImageSrc)</l>
<l>dev_display(RegionDilation)</l>
<c></c>
<l>stop()</l>
<c></c>
<c>* 遍历图像序列</c>
<l>count_obj(RegionDilation, Number)</l>
<l>for I:=1 to 80 by 1</l>
<c>    * 前一帧</c>
<l>    read_image(ImagePrev, 'C:/Users/7723/Desktop/codes/halcon/PicAndTemplate/V1001559/' + (I-1))</l>
<c>    </c>
<l>    count_channels(ImagePrev, Channels)</l>
<l>    if(Channels == 3)</l>
<l>        rgb1_to_gray(ImagePrev, ImagePrev)</l>
<l>    endif</l>
<c>    </c>
<l>    gauss_filter(ImagePrev, ImagePrevGauss, 7)</l>
<c>    </c>
<c>    * 后一帧</c>
<l>    read_image(ImageRear, 'C:/Users/7723/Desktop/codes/halcon/PicAndTemplate/V1001559/' + I)</l>
<c>    </c>
<l>    count_channels(ImageRear, Channels)</l>
<l>    if(Channels == 3)</l>
<l>        rgb1_to_gray(ImageRear, ImageRear)</l>
<l>    endif</l>
<c>    </c>
<l>    gauss_filter(ImageRear, ImageRearGauss, 7)</l>
<c>    </c>
<c>    * 输出的细胞运动路径图</c>
<l>    gen_image_const(ImageCellR, 'byte', Width, Height)</l>
<l>    gen_image_const(ImageCellG, 'byte', Width, Height)</l>
<l>    gen_image_const(ImageCellB, 'byte', Width, Height)</l>
<l>    copy_image(ImagePrev, ImageCellTrackR)</l>
<l>    copy_image(ImagePrev, ImageCellTrackG)</l>
<l>    copy_image(ImagePrev, ImageCellTrackB)</l>
<c>    </c>
<c>    * 遍历ROI</c>
<l>    for J := 1 to Number by 1        </l>
<c>        * 选择1个ROI 并 使用其图形边缘作为形状模板</c>
<l>        select_obj(RegionDilation, RegionSelected, J)</l>
<l>        boundary(RegionSelected, RegionBorder, 'inner')        </l>
<l>        reduce_domain(ImageGauss, RegionBorder, ImageReduced)</l>
<c></c>
<c>        * 生成形状模板 参数为：金字塔级别2(级别越低 效率越低 模板轮廓越清晰) 从-12度开始范围12度步进为0.4 缩放尺度为0.92~1.08步进0.02 自动优化方案 背景对比度可变化 自动对比度 自动最小对比度</c>
<c>        * 参考 https://www.cxyzjd.com/article/surui_555/48268473</c>
<l>        try</l>
<l>            create_scaled_shape_model(ImageReduced, 2, rad(-15), rad(15), rad(0.4), 0.92, 1.08, 0.02, 'pregeneration', 'ignore_global_polarity', 'auto', 'auto', ModelShape)</l>
<l>        catch (Exception)</l>
<l>            continue</l>
<l>        endtry</l>
<c>        </c>
<c>        * 设置模板原点</c>
<l>        area_center(RegionBorder, Area, RowCenter, ColCenter)</l>
<l>        set_shape_model_origin(ModelShape, -RowCenter, -ColCenter)</l>
<c>        </c>
<c>        * 获取模板的轮廓</c>
<l>        get_shape_model_contours (ModelContours, ModelShape, 1)</l>
<l>        gen_region_contour_xld(ModelContours, ModelRegion, 'filled')</l>
<l>        union1(ModelRegion, ModelROIRegionUnion)</l>
<c>        </c>
<c>        * 调试显示</c>
<l>        dev_display(ImagePrev)</l>
<l>        dev_display(ModelContours)</l>
<c>        </c>
<c>        * 形状模板匹配 </c>
<c>        * 要求：最低匹配分数0.75 最多找到3个相似形状 最少0.6的形状完整度 贪心度0.3（越低 速度越慢 寻找到的可能性越高）</c>
<c>        * RowRead：形状位移y    ColRead：形状位移x    Angle：旋转角度    Scale：尺寸缩放</c>
<l>        find_scaled_shape_model(ImagePrevGauss, ModelShape, rad(-15), rad(15), 0.92, 1.08, 0.75, 3, 0.6, 'least_squares', 2, 0.3, RowTranPrev, ColTranPrev, AngleTranPrev, ScaleTranPrev, ScorePrev)</l>
<l>        find_scaled_shape_model(ImageRearGauss, ModelShape, rad(-15), rad(15), 0.92, 1.08, 0.75, 3, 0.6, 'least_squares', 2, 0.3, RowTranRear, ColTranRear, AngleTranRear, ScaleTranRear, ScoreRear)</l>
<c>        </c>
<c>        * 不为0时说明匹配到了相同的形状</c>
<l>        maxArea := 0</l>
<l>        maxAreaIndexPrev := -1</l>
<l>        if(|RowTranPrev|)            </l>
<c>            * 遍历每一个匹配到的形状 选择最合理的一个匹配区域</c>
<l>            for K:=0 to |RowTranPrev|-1 by 1</l>
<c>                * 模板坐标转换</c>
<l>                hom_mat2d_identity (HomMat2D)</l>
<l>                hom_mat2d_scale (HomMat2D, ScaleTranPrev[K], ScaleTranPrev[K], 0, 0, HomMat2D)</l>
<l>                hom_mat2d_rotate (HomMat2D, AngleTranPrev[K], 0, 0, HomMat2D)</l>
<l>                hom_mat2d_translate (HomMat2D, RowTranPrev[K], ColTranPrev[K], HomMat2D)</l>
<l>                affine_trans_contour_xld(ModelContours, ModelContoursTrans, HomMat2D)</l>
<c>                </c>
<c>                * 计算和ROI模板的重合区域 有接触就说明模板匹配在合理范围之内</c>
<l>                gen_region_contour_xld(ModelContoursTrans, ModelRegionTrans, 'margin')</l>
<l>                union1(ModelRegionTrans, ModelRegionTransUnion)</l>
<l>                intersection(ModelRegionTransUnion, ModelROIRegionUnion, RegionIntersection)</l>
<c>                </c>
<c>                * 判断重合区域是不是为空 如果重合面积大于0 则不为空</c>
<l>                area_center(RegionIntersection, AreaInsc, RowInsc, ColumnInsc)</l>
<c>                </c>
<c>                * 找位置最接近的匹配区域 即重合面积最大的区域</c>
<l>                if(AreaInsc&gt;maxArea)</l>
<l>                    maxArea := AreaInsc</l>
<l>                    maxAreaIndexPrev := K</l>
<l>*                     stop()</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endif</l>
<c>        </c>
<c>        * Again for Rear</c>
<l>        maxArea := 0</l>
<l>        maxAreaIndexRear := -1</l>
<l>        if(|RowTranRear|)            </l>
<l>            for K:=0 to |RowTranRear|-1 by 1</l>
<l>                hom_mat2d_identity (HomMat2D)</l>
<l>                hom_mat2d_scale (HomMat2D, ScaleTranRear[K], ScaleTranRear[K], 0, 0, HomMat2D)</l>
<l>                hom_mat2d_rotate (HomMat2D, AngleTranRear[K], 0, 0, HomMat2D)</l>
<l>                hom_mat2d_translate (HomMat2D, RowTranRear[K], ColTranRear[K], HomMat2D)</l>
<l>                affine_trans_contour_xld(ModelContours, ModelContoursTrans, HomMat2D)</l>
<c>                </c>
<l>                gen_region_contour_xld(ModelContoursTrans, ModelRegionTrans, 'margin')</l>
<l>                union1(ModelRegionTrans, ModelRegionTransUnion)</l>
<l>                intersection(ModelRegionTransUnion, ModelROIRegionUnion, RegionIntersection)</l>
<c>                </c>
<l>                area_center(RegionIntersection, AreaInsc, RowInsc, ColumnInsc)</l>
<c>                </c>
<l>                if(AreaInsc&gt;maxArea)</l>
<l>                    maxArea := AreaInsc</l>
<l>                    maxAreaIndexRear := K</l>
<l>*                     stop()</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endif</l>
<c>            </c>
<c>        * 找到合理范围内 位置最接近的区域</c>
<l>        if(maxAreaIndexPrev != -1 and maxAreaIndexRear != -1)</l>
<c>            * Prev</c>
<l>            hom_mat2d_identity (HomMat2D)</l>
<l>            hom_mat2d_scale (HomMat2D, ScaleTranPrev[maxAreaIndexPrev], ScaleTranPrev[maxAreaIndexPrev], 0, 0, HomMat2D)</l>
<l>            hom_mat2d_rotate (HomMat2D, AngleTranPrev[maxAreaIndexPrev], 0, 0, HomMat2D)</l>
<l>            hom_mat2d_translate (HomMat2D, RowTranPrev[maxAreaIndexPrev], ColTranPrev[maxAreaIndexPrev], HomMat2D)</l>
<l>            hom_mat2d_invert(HomMat2D, HomMat2DInvert)</l>
<l>            affine_trans_image(ImagePrevGauss, ImagePrevGaussTrans, HomMat2DInvert, 'nearest_neighbor', 'false')</l>
<c>            </c>
<c>            * Rear</c>
<l>            hom_mat2d_identity (HomMat2D)</l>
<l>            hom_mat2d_scale (HomMat2D, ScaleTranRear[maxAreaIndexRear], ScaleTranRear[maxAreaIndexRear], 0, 0, HomMat2D)</l>
<l>            hom_mat2d_rotate (HomMat2D, AngleTranRear[maxAreaIndexRear], 0, 0, HomMat2D)</l>
<l>            hom_mat2d_translate (HomMat2D, RowTranRear[maxAreaIndexRear], ColTranRear[maxAreaIndexRear], HomMat2D)</l>
<l>            hom_mat2d_invert(HomMat2D, HomMat2DInvert)</l>
<l>            affine_trans_image(ImageRearGauss, ImageRearGaussTrans, HomMat2DInvert, 'nearest_neighbor', 'false')</l>
<c>            </c>
<c>            * 计算前后两帧的区别</c>
<l>            reduce_domain(ImagePrevGaussTrans, RegionSelected, ImagePrevCalRegion)</l>
<l>            reduce_domain(ImageRearGaussTrans, RegionSelected, ImageRearCalRegion)</l>
<c>                      </c>
<c>            ****************************卡尔曼滤波BEGIN****************************</c>
<l>            create_bg_esti(ImagePrevCalRegion, 0.7, 0.7, 'fixed', 0.002, 0.02, 'on', 7, 10, 3.25, 15, BgEstiHandle)</l>
<l>            run_bg_esti(ImageRearCalRegion, ForegroundRegion, BgEstiHandle)</l>
<c>            </c>
<l>            connection(ForegroundRegion, ConnectedCellTrackRegion)</l>
<l>            union1(ConnectedCellTrackRegion, RegionCell)</l>
<c>            ****************************卡尔曼滤波END****************************</c>
<c>            </c>
<l>            boundary(RegionCell, RegionCellBorder, 'inner')</l>
<c>            </c>
<c>            * 调试显示</c>
<l>            dev_clear_window()</l>
<l>            dev_display(ImageSrc)</l>
<l>            dev_display(RegionCellBorder)</l>
<c>            </c>
<l>            boundary(RegionSelected, RegionSelectedTransPrevBorder, 'inner')</l>
<c>            </c>
<l>            overpaint_region(ImageCellR, RegionSelectedTransPrevBorder, 0, 'fill')</l>
<l>            overpaint_region(ImageCellG, RegionSelectedTransPrevBorder, 255, 'fill')</l>
<l>            overpaint_region(ImageCellB, RegionSelectedTransPrevBorder, 0, 'fill')</l>
<c>            </c>
<l>            overpaint_region(ImageCellR, RegionCell, 255, 'fill')</l>
<l>            overpaint_region(ImageCellG, RegionCell, 0, 'fill')</l>
<l>            overpaint_region(ImageCellB, RegionCell, 0, 'fill')</l>
<c>            </c>
<l>            overpaint_region(ImageCellTrackR, RegionSelectedTransPrevBorder, 0, 'fill')</l>
<l>            overpaint_region(ImageCellTrackG, RegionSelectedTransPrevBorder, 255, 'fill')</l>
<l>            overpaint_region(ImageCellTrackB, RegionSelectedTransPrevBorder, 0, 'fill')</l>
<c>            </c>
<l>            overpaint_region(ImageCellTrackR, RegionCellBorder, 255, 'fill')</l>
<l>            overpaint_region(ImageCellTrackG, RegionCellBorder, 0, 'fill')</l>
<l>            overpaint_region(ImageCellTrackB, RegionCellBorder, 0, 'fill')</l>
<c>            </c>
<c>            * TODO 计算流动</c>
<c>            * do sth.</c>
<c>            </c>
<l>*             stop()</l>
<l>        else</l>
<c>            * 找到对应模板形状 但模板匹配不在合理范围内</c>
<l>*             stop()</l>
<l>        endif</l>
<l>    endfor</l>
<c>    </c>
<l>    compose3(ImageCellR, ImageCellG, ImageCellB, ImageRGB)</l>
<l>    compose3(ImageCellTrackR, ImageCellTrackG, ImageCellTrackB, ImageCellTrackRGB)</l>
<c>    </c>
<l>    write_image(ImageRGB, 'png', 0, 'C:/Users/7723/Desktop/codes/halcon/PicAndTemplate/V1001559/1_CellTrack/' + (I-1) + '_' + I + '.png')</l>
<l>    write_image(ImageCellTrackRGB, 'png', 0, 'C:/Users/7723/Desktop/codes/halcon/PicAndTemplate/V1001559/1_CellTrack/track' + (I-1) + '_' + I + '.png')</l>
<l>*     stop()</l>
<l>endfor</l>
<c></c>
<l>stop()</l>
<c>***************************************新型防抖骗术END***************************************</c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="patchPreProcessBorderImage">
<interface/>
<body>
<c>* 批量 通用预处理 并 输出边缘图</c>
<l>dev_set_line_width(1)</l>
<l>for I:=0 to 10 by 1</l>
<l>    read_image(ImageSrc, 'C:/Users/7723/Desktop/codes/halcon/PicAndTemplate/V1001559/0_source/' + I)</l>
<c>    </c>
<l>    get_image_size(ImageSrc, Width, Height)</l>
<c></c>
<l>    count_channels(ImageSrc, Channels)</l>
<l>    if(Channels == 3)</l>
<l>        rgb1_to_gray(ImageSrc, ImageSrc)</l>
<l>    endif</l>
<c>    </c>
<l>    dev_close_window()</l>
<l>    dev_open_window(0, 0, Width, Height, 'black', WindowHandle)</l>
<l>    dev_display(ImageSrc)</l>
<c>    </c>
<l>    illuminate (ImageSrc, ImageSrcIlluminate, 40, 40, 0.55)</l>
<l>    gauss_filter(ImageSrcIlluminate, ImageSrcGauss, 7)</l>
<c>    </c>
<c>    * 转成浮点格式 拓宽可计算范围</c>
<l>    convert_image_type(ImageSrcGauss, ImageSrcGaussReal, 'real')</l>
<c>    </c>
<c>    * 0点 0点左边 0点下边 各截一张图</c>
<l>    crop_part(ImageSrcGaussReal, Image00, 0, 0, Width-2, Height-2)</l>
<l>    crop_part(ImageSrcGaussReal, Image01, 0, 2, Width-2, Height-2)</l>
<l>    crop_part(ImageSrcGaussReal, Image10, 2, 0, Width-2, Height-2)</l>
<c>    </c>
<c>    * 求水平方向和垂直方向的边缘图</c>
<l>    sub_image(Image01, Image00, ImageBorderHor, 1, 0)</l>
<l>    sub_image(Image10, Image00, ImageBorderVer, 1, 0)</l>
<c>    </c>
<c>    * 取平方强化边缘图</c>
<l>    mult_image(ImageBorderHor, ImageBorderHor, ImageResult1, 1, 0)</l>
<l>    mult_image(ImageBorderVer, ImageBorderVer, ImageResult2, 1, 0)</l>
<c>    </c>
<c>    * 得到完整边缘图</c>
<l>    add_image(ImageResult1, ImageResult2, ImageBorder, 1, 0)</l>
<c>    </c>
<c>    * 转回字节格式</c>
<l>    gen_rectangle1(Rectangle, 0, 0, Height-1, Width-1)</l>
<l>    min_max_gray(Rectangle, ImageBorder, 0, Min, Max, Range)</l>
<l>    scale_image(ImageBorder, ImageScaled, 255.0/(Max-Min), 0)</l>
<l>    convert_image_type(ImageScaled, ImageBorderByte, 'byte')</l>
<c>    </c>
<l>    edges_image(ImageBorderByte, ImaAmp, ImaDir, 'canny', 1, 'nms', 5, 20)</l>
<c>    </c>
<c>    * 得到边缘轮廓区域</c>
<l>    threshold(ImaDir, BorderRegion, 20, 255)</l>
<l>    fill_up(BorderRegion, RegionFillUp)</l>
<c>    </c>
<l>    connection(BorderRegion, ConnectedRegions)</l>
<l>    select_shape(ConnectedRegions, AreaBorderRegion, 'area', 'and', 300, Width*Height)</l>
<l>    union1(AreaBorderRegion, RegionUnion)</l>
<c>    </c>
<l>    gen_rectangle1(rect, 0, 0, Height-1, Width-1)</l>
<l>    difference(rect, RegionUnion, rr)</l>
<l>    reduce_domain(ImageSrc, rr, ImageReduced)</l>
<l>    crop_domain(ImageReduced, ImagePart)</l>
<l>    mean_image(ImagePart, ImageMean, Width, Height)</l>
<c>    </c>
<l>    gen_image_const(ImageWrite, 'byte', Width, Height)</l>
<l>    paint_region(RegionUnion, ImageWrite, ImageWrite, 255, 'fill')</l>
<c>    </c>
<l>    write_image(ImageWrite, 'png', 0, 'C:/Users/7723/Desktop/codes/halcon/PicAndTemplate/V1001559/1_border/' + I + '.png')</l>
<l>endfor</l>
<c></c>
<l>return ()</l>
</body>
<docu id="patchPreProcessBorderImage">
<parameters/>
</docu>
</procedure>
</hdevelop>
