<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.3.0">
<procedure name="main">
<interface/>
<body>
<c>***************************************清晰度BEGIN***************************************</c>
<c>* 清晰度算法另作函数get_image_sharpnessx单独调用 在内部调用了自定义预处理函数pre_process </c>
<c>* 合理清晰度暂定为[0.91, 1.195)</c>
<c>* 以下为使用demo 测试集主要选用 V1001559 EV_PIC vh(栅格垂直水平) white</c>
<l>* dev_update_off()</l>
<l>* Sharpnesses := []</l>
<l>* for I := 0 to 540 by 1</l>
<l>*     get_image_sharpness (Image, 'D:/codes/PicAndTemplate/white/', I$'04', Sharpness)</l>
<l>*     Sharpnesses := [Sharpnesses, Sharpness]</l>
<l>*     write_image(Image, 'png', 0, 'D:/codes/PicAndTemplate/white/Sharpness/' + I + '_'+ Sharpness + '.png')</l>
<l>* endfor</l>
<l>* tuple_sort(Sharpnesses, Sorted)</l>
<l>* tuple_inverse(Sorted, Inverted)</l>
<l>* tuple_sort_index(Sharpnesses, Indices)</l>
<l>* tuple_inverse(Indices, Inverted1)</l>
<c>***************************************清晰度END***************************************</c>
<c></c>
<c>***************************************消抖+流动轨迹面积BEGIN***************************************</c>
<l>Areas := []</l>
<l>dev_update_off()</l>
<c></c>
<l>firstIndex := 0</l>
<c></c>
<c>* 首帧预处理 对应的变量用在后续的后帧缓存</c>
<l>pre_process (ImagePrev, ImagePrevGauss, RegionConnectedPrev, NeedSplitRegionsPrev, 'D:/codes/PicAndTemplate/EV_PIC/', firstIndex, Width, Height)</l>
<c></c>
<c>***************************************血管分段BEGIN***************************************</c>
<c>* 清晰度算法另作函数split_vessel_region单独调用 </c>
<c>* 注意：调用顺序必须在 预处理得到血管区域集合以及高斯滤波图像 之后！！</c>
<c>* Branch分支 Node结点</c>
<l>* split_vessel_region (RegionConnectedPrev, ImagePrevGauss, RegionBranchs, RegionNodes, Width, Height)</l>
<c></c>
<l>* union1(RegionNodes, UnionRegionNodes)</l>
<l>* dev_clear_window()</l>
<l>* dev_display(RegionBranchs)</l>
<l>* dev_display(UnionRegionNodes)</l>
<c>***************************************血管分段END***************************************</c>
<c></c>
<c>* 遍历图像序列</c>
<l>for I:=firstIndex+1 to firstIndex+100 by 1</l>
<c>    * 前帧血管区域判空 若为空 next one</c>
<l>    area_center(NeedSplitRegionsPrev, AreaNeedSplitRegionsPrev, useless, useless)</l>
<l>    if(|AreaNeedSplitRegionsPrev| == 0 or -1 == AreaNeedSplitRegionsPrev)</l>
<l>        pre_process (ImagePrev, ImagePrevGauss, RegionConnectedPrev, NeedSplitRegionsPrev, 'D:/codes/PicAndTemplate/EV_PIC/', I, Width, Height)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * 后一帧预处理</c>
<l>    pre_process (ImageRear, ImageRearGauss, RegionConnectedRear, NeedSplitRegionsRear, 'D:/codes/PicAndTemplate/EV_PIC/', I, Width, Height)</l>
<c>    </c>
<c>    * 后帧血管区域判空 若为空 next one</c>
<l>    area_center(NeedSplitRegionsRear, AreaNeedSplitRegionsRear, useless, useless)</l>
<l>    if(|AreaNeedSplitRegionsRear| == 0 or -1 == AreaNeedSplitRegionsRear)</l>
<l>        I := I + 1</l>
<l>        pre_process (ImagePrev, ImagePrevGauss, RegionConnectedPrev, NeedSplitRegionsPrev, 'D:/codes/PicAndTemplate/EV_PIC/', I, Width, Height)</l>
<l>        continue</l>
<l>    endif</l>
<c>    </c>
<c>    * 调试显示 前后两帧的血管位置差异大不大</c>
<l>*     dev_clear_window()</l>
<l>*     dev_display(NeedSplitRegionsPrev)</l>
<l>*     dev_display(NeedSplitRegionsRear)</l>
<c>    </c>
<c>    * 前后帧差异区域</c>
<l>    difference(NeedSplitRegionsPrev, NeedSplitRegionsRear, RegionDifference)</l>
<c>    </c>
<c>    * 计算差异区域在各行的宽度</c>
<l>    dis_Row := []</l>
<l>    for J:=0 to Height-1 by 1</l>
<l>        gen_region_line(Line, J, 0, J, Width-1)</l>
<l>        intersection(Line, RegionDifference, RegionIntersection)</l>
<l>        connection(RegionIntersection, ConnectedRegions)</l>
<l>        area_center(ConnectedRegions, AreaRow, useless, useless)</l>
<l>        dis_Row := [dis_Row, AreaRow]</l>
<l>    endfor</l>
<c>    </c>
<c>    * 计算差异区域在各列的高度</c>
<l>    dis_Col := []</l>
<l>    for J:=0 to Width-1 by 1</l>
<l>        gen_region_line(Line, 0, J, Height-1, J)</l>
<l>        intersection(Line, RegionDifference, RegionIntersection)</l>
<l>        connection(RegionIntersection, ConnectedRegions)</l>
<l>        area_center(ConnectedRegions, AreaCol, useless, useless)</l>
<l>        dis_Col := [dis_Col, AreaCol]</l>
<l>    endfor</l>
<c>    </c>
<c>    * 最大距离的正负作为粗瞄范围 方差作为步进粗瞄距离</c>
<l>    tuple_max(dis_Row, maxRowDis)</l>
<l>    tuple_deviation(dis_Row, deviationRowDis)</l>
<l>    tuple_max(dis_Col, maxColDis)</l>
<l>    tuple_deviation(dis_Col, deviationColDis)</l>
<c>    </c>
<c>    * 粗瞄 找出一个横向移动后 能使前后帧血管区域重叠面积最大的差异区域高度 减少后面防抖移动的次数</c>
<c>    * 插值方式采用比较粗糙的nearest_neighbor即可 后面浮点数处再采用比较精准的插值方法</c>
<l>    maxIntersectAreaRow := 0</l>
<l>    maxIntersectAreaCol := 0</l>
<l>    maxIntersectArea := 0</l>
<c>    </c>
<l>    for Row:=-maxRowDis to maxRowDis by deviationRowDis</l>
<l>        for Col:=-maxColDis to maxColDis by deviationColDis</l>
<l>            hom_mat2d_identity(HomMat2D)</l>
<l>            hom_mat2d_translate(HomMat2D, Row, Col, HomMat2D)</l>
<l>            affine_trans_region(NeedSplitRegionsRear, NeedSplitRegionsRearTrans, HomMat2D, 'nearest_neighbor')</l>
<c>            </c>
<l>            intersection(NeedSplitRegionsPrev, NeedSplitRegionsRearTrans, RegionIntersect)</l>
<l>            area_center(RegionIntersect, AreaRegionIntersect, RowRegionIntersect, ColumnRegionIntersect)</l>
<l>            if(AreaRegionIntersect &gt; maxIntersectArea)</l>
<l>                maxIntersectArea := AreaRegionIntersect</l>
<l>                maxIntersectAreaRow := Row</l>
<l>                maxIntersectAreaCol := Col</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<c>    </c>
<c>    * 细瞄 将前帧的血管区域移动至的重叠面积最大的地方 达到防抖的效果</c>
<c>    * J循环是为了多找一次 提高精度</c>
<l>    for J:=0 to 1 by 1</l>
<l>        for X:=-2.56 to 2.56 by 0.16</l>
<l>            hom_mat2d_identity(HomMat2D)</l>
<l>            hom_mat2d_translate(HomMat2D, maxIntersectAreaRow, maxIntersectAreaCol+X, HomMat2D)</l>
<l>            affine_trans_region(NeedSplitRegionsRear, NeedSplitRegionsRearTrans, HomMat2D, 'constant')</l>
<c>            </c>
<l>            intersection(NeedSplitRegionsPrev, NeedSplitRegionsRearTrans, RegionIntersect)</l>
<l>            area_center(RegionIntersect, AreaRegionIntersect, RowRegionIntersect, ColumnRegionIntersect)</l>
<l>            if(AreaRegionIntersect &gt; maxIntersectArea)</l>
<l>                maxIntersectArea := AreaRegionIntersect</l>
<l>                maxIntersectAreaCol := maxIntersectAreaCol+X</l>
<l>            endif</l>
<l>        endfor</l>
<c>        </c>
<l>        for Y:=-2.56 to 2.56 by 0.16</l>
<l>            hom_mat2d_identity(HomMat2D)</l>
<l>            hom_mat2d_translate(HomMat2D, maxIntersectAreaRow+Y, maxIntersectAreaCol, HomMat2D)</l>
<l>            affine_trans_region(NeedSplitRegionsRear, NeedSplitRegionsRearTrans, HomMat2D, 'constant')</l>
<c>            </c>
<l>            intersection(NeedSplitRegionsPrev, NeedSplitRegionsRearTrans, RegionIntersect)</l>
<l>            area_center(RegionIntersect, AreaRegionIntersect, RowRegionIntersect, ColumnRegionIntersect)</l>
<l>            if(AreaRegionIntersect &gt; maxIntersectArea)</l>
<l>                maxIntersectArea := AreaRegionIntersect</l>
<l>                maxIntersectAreaRow := maxIntersectAreaRow+Y</l>
<l>            endif</l>
<l>        endfor</l>
<l>    endfor</l>
<c>    </c>
<c>    * 最终找到 后帧对前帧的最佳移动位置</c>
<l>    hom_mat2d_identity(HomMat2D)</l>
<l>    hom_mat2d_translate(HomMat2D, maxIntersectAreaRow, maxIntersectAreaCol, HomMat2D)</l>
<l>    affine_trans_region(NeedSplitRegionsRear, NeedSplitRegionsRearTrans, HomMat2D, 'constant')</l>
<l>    affine_trans_image(ImageRearGauss, ImageRearGaussTrans, HomMat2D, 'constant', 'false')</l>
<c>    </c>
<c>    * 合并前后帧血管区域 形成一个膨胀的、前后血管区域兼备的ROI</c>
<c>    * 并计算连通区域 得到最终的ROI区域</c>
<l>    union2(NeedSplitRegionsPrev, NeedSplitRegionsRearTrans, NeedSplitRegionsPrevRear)</l>
<l>*     dev_clear_window()</l>
<l>*     dev_display(ImageRearGaussTrans)</l>
<l>*     dev_display(NeedSplitRegionsPrevRear)</l>
<c>    </c>
<c>    * 输出膨胀后的血管检测区域 调试用</c>
<l>*     debug_output_vesselConnect (NeedSplitRegionsPrevRear, ImagePrev, ImageRear, 'D:/codes/PicAndTemplate/EV_PIC/1_CellTrack/_vesselConnect', I)</l>
<c>        </c>
<c>    * 计算前后两帧的区别</c>
<l>    reduce_domain(ImagePrevGauss, NeedSplitRegionsPrevRear, ImagePrevCalRegion)</l>
<l>    reduce_domain(ImageRearGaussTrans, NeedSplitRegionsPrevRear, ImageRearCalRegion)</l>
<c>    </c>
<c>    * 由于后帧发生过移动 因此ROI截取到的位置不一定完全重叠</c>
<l>    intersection(ImagePrevCalRegion, ImageRearCalRegion, ROIintersection)</l>
<c>    </c>
<c>    * 截取最终的血管区域</c>
<l>    reduce_domain(ImagePrevGauss, ROIintersection, ImagePrevCalRegion)</l>
<l>    reduce_domain(ImageRearGaussTrans, ROIintersection, ImageRearCalRegion)</l>
<c>    </c>
<c>    * 用帧差法检测流动轨迹</c>
<c>    * 先直方图均衡降低亮度变化带来的影响</c>
<c>    * 红细胞是低灰度 背景是高灰度 要获取红细胞轨迹 应该先反转灰度再相减</c>
<l>    equ_histo_image(ImagePrevCalRegion, ImagePrevCalRegionEquHisto)</l>
<l>    equ_histo_image(ImageRearCalRegion, ImageRearCalRegionEquHisto)</l>
<l>    invert_image(ImagePrevCalRegionEquHisto, ImagePrevCalRegionInvert)</l>
<l>    invert_image(ImageRearCalRegionEquHisto, ImageRearCalRegionInvert)</l>
<l>    sub_image(ImageRearCalRegionInvert, ImagePrevCalRegionInvert, ImageCellTrackRegion, 1, 0)</l>
<c>    </c>
<l>    mean_image(ImageCellTrackRegion, ImageMean, 43, 43)</l>
<l>    dyn_threshold(ImageCellTrackRegion, ImageMean, RegionCellTrack, 6, 'light')</l>
<c>    </c>
<c>    * 输出前后帧血管截图 调试用</c>
<l>*     debug_output_calRegion_Prev_Rear(ImagePrevCalRegionEquHisto, ImageRearCalRegionEquHisto, 'D:/codes/PicAndTemplate/EV_PIC/1_CellTrack/calRegion', I)</l>
<c>    </c>
<c>    * 输出/调试显示</c>
<l>*     boundary(RegionCellTrack, RegionCellTrackBorder, 'inner')</l>
<l>*     dev_clear_window()</l>
<l>*     dev_display(ImagePrev)</l>
<l>*     dev_display(RegionCellTrackBorder)</l>
<c>    </c>
<l>*     stop()</l>
<c>    </c>
<c>    * debug输出用的图像 1.ImageCellTrackR 细胞运动路径图 2.ImageCellTrack_bg_R 带背景(bg)的细胞运动路径图</c>
<l>*     debug_output_track_and_track_bg(ImagePrev, NeedSplitRegionsPrevRear, RegionCellTrack, Width, Height, 'D:/codes/PicAndTemplate/EV_PIC/1_CellTrack/track', I)</l>
<c></c>
<c>    * 计算流动轨迹面积</c>
<c>    * 令 红细胞流速(mm/ms) = 流动轨迹面积(px) * 像素尺寸(mm/px) / 放大倍率 / 前后帧时间差(ms)</c>
<c>    * 以大恒为例 若算出AB帧之间轨迹面积为1000px 像素尺寸为常量5.6um/px 放大倍率为常量5 帧率为常量30fps</c>
<c>    * 则AB帧之间的流速为 1000 * (5.6/1000) / 5 / (1000/30) = 5.6 / 5 / 1000 * 30 = 0.0336mm/ms</c>
<l>    area_center(RegionCellTrack, RegionCellTracksArea, RegionCellTracksRow, RegionCellTracksColumn)    </l>
<l>    Areas := [Areas, RegionCellTracksArea]</l>
<c></c>
<c>    * 后帧变前帧</c>
<l>    ImagePrev := ImageRear</l>
<l>    ImagePrevGauss := ImageRearGauss</l>
<l>    NeedSplitRegionsPrev := NeedSplitRegionsRear</l>
<c>    </c>
<l>*     stop()</l>
<l>endfor</l>
<c>***************************************消抖+流动轨迹面积END***************************************</c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="debug_output_vesselConnect">
<interface>
<io>
<par name="RegionUnionPrevRear" base_type="iconic" dimension="0"/>
<par name="ImagePrev" base_type="iconic" dimension="0"/>
<par name="ImageRear" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* 输出膨胀后的血管检测区域 调试用</c>
<l>boundary(RegionUnionPrevRear, RegionUnionPrevRearBorder, 'inner')</l>
<c></c>
<l>copy_image(ImagePrev, ImageVesselR)</l>
<l>copy_image(ImagePrev, ImageVesselG)</l>
<l>copy_image(ImagePrev, ImageVesselB)</l>
<c></c>
<l>overpaint_region(ImageVesselR, RegionUnionPrevRearBorder, 255, 'fill')</l>
<l>overpaint_region(ImageVesselG, RegionUnionPrevRearBorder, 0, 'fill')</l>
<l>overpaint_region(ImageVesselB, RegionUnionPrevRearBorder, 0, 'fill')</l>
<c></c>
<l>compose3(ImageVesselR, ImageVesselG, ImageVesselB, ImageVesselRGB)</l>
<c></c>
<l>write_image(ImageVesselRGB, 'png', 0, path + (Index-1) + 'Prev.png')</l>
<c></c>
<l>copy_image(ImageRear, ImageVesselR)</l>
<l>copy_image(ImageRear, ImageVesselG)</l>
<l>copy_image(ImageRear, ImageVesselB)</l>
<c></c>
<l>overpaint_region(ImageVesselR, RegionUnionPrevRearBorder, 255, 'fill')</l>
<l>overpaint_region(ImageVesselG, RegionUnionPrevRearBorder, 0, 'fill')</l>
<l>overpaint_region(ImageVesselB, RegionUnionPrevRearBorder, 0, 'fill')</l>
<c></c>
<l>compose3(ImageVesselR, ImageVesselG, ImageVesselB, ImageVesselRGB)</l>
<c></c>
<l>write_image(ImageVesselRGB, 'png', 0, path + (Index-1) + 'Rear.png')</l>
<c></c>
<l>return ()</l>
</body>
<docu id="debug_output_vesselConnect">
<parameters>
<parameter id="ImagePrev"/>
<parameter id="ImageRear"/>
<parameter id="Index"/>
<parameter id="RegionUnionPrevRear"/>
<parameter id="path"/>
</parameters>
</docu>
</procedure>
<procedure name="debug_output_calRegion_Prev_Rear">
<interface>
<io>
<par name="ImagePrevCalRegion" base_type="iconic" dimension="0"/>
<par name="ImageRearCalRegion" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>area_center(ImagePrevCalRegion, Area, Row, Column)</l>
<l>area_center(ImageRearCalRegion, Area1, Row1, Column1)</l>
<l>if(|Area| and |Area1|)</l>
<l>    write_image(ImagePrevCalRegion, 'png', 0, path + (Index-1) + '_' + Index + 'Prev.png')</l>
<l>    write_image(ImageRearCalRegion, 'png', 0, path + (Index-1) + '_' + Index + 'Rear.png')</l>
<l>endif</l>
<l>return ()</l>
</body>
<docu id="debug_output_calRegion_Prev_Rear">
<parameters>
<parameter id="ImagePrevCalRegion"/>
<parameter id="ImageRearCalRegion"/>
<parameter id="Index"/>
<parameter id="path"/>
</parameters>
</docu>
</procedure>
<procedure name="debug_output_track_and_track_bg">
<interface>
<io>
<par name="ImagePrev" base_type="iconic" dimension="0"/>
<par name="RegionUnionPrevRear" base_type="iconic" dimension="0"/>
<par name="RegionCellTrack" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>boundary(RegionUnionPrevRear, RegionUnionPrevRearBorder, 'inner')</l>
<l>boundary(RegionCellTrack, RegionCellTracksBorder, 'inner')</l>
<c></c>
<l>gen_image_const(ImageCellTrackR, 'byte', Width, Height)</l>
<l>gen_image_const(ImageCellTrackG, 'byte', Width, Height)</l>
<l>gen_image_const(ImageCellTrackB, 'byte', Width, Height)</l>
<l>copy_image(ImagePrev, ImageCellTrack_bg_R)</l>
<l>copy_image(ImagePrev, ImageCellTrack_bg_G)</l>
<l>copy_image(ImagePrev, ImageCellTrack_bg_B)</l>
<c></c>
<l>overpaint_region(ImageCellTrackR, RegionUnionPrevRearBorder, 0, 'fill')</l>
<l>overpaint_region(ImageCellTrackG, RegionUnionPrevRearBorder, 255, 'fill')</l>
<l>overpaint_region(ImageCellTrackB, RegionUnionPrevRearBorder, 0, 'fill')</l>
<c></c>
<l>overpaint_region(ImageCellTrackR, RegionCellTrack, 255, 'fill')</l>
<l>overpaint_region(ImageCellTrackG, RegionCellTrack, 0, 'fill')</l>
<l>overpaint_region(ImageCellTrackB, RegionCellTrack, 0, 'fill')</l>
<c></c>
<l>overpaint_region(ImageCellTrack_bg_R, RegionUnionPrevRearBorder, 0, 'fill')</l>
<l>overpaint_region(ImageCellTrack_bg_G, RegionUnionPrevRearBorder, 255, 'fill')</l>
<l>overpaint_region(ImageCellTrack_bg_B, RegionUnionPrevRearBorder, 0, 'fill')</l>
<c></c>
<l>overpaint_region(ImageCellTrack_bg_R, RegionCellTracksBorder, 255, 'fill')</l>
<l>overpaint_region(ImageCellTrack_bg_G, RegionCellTracksBorder, 0, 'fill')</l>
<l>overpaint_region(ImageCellTrack_bg_B, RegionCellTracksBorder, 0, 'fill')</l>
<c></c>
<l>compose3(ImageCellTrackR, ImageCellTrackG, ImageCellTrackB, ImageRGB)</l>
<l>compose3(ImageCellTrack_bg_R, ImageCellTrack_bg_G, ImageCellTrack_bg_B, ImageCellTrackRGB)</l>
<c></c>
<l>write_image(ImageRGB, 'png', 0, path + (Index-1) + '_' + Index + '.png')</l>
<l>write_image(ImageCellTrackRGB, 'png', 0, path + 'bg_' + (Index-1) + '_' + Index + '.png')</l>
<c>    </c>
<l>return ()</l>
</body>
<docu id="debug_output_track_and_track_bg">
<parameters>
<parameter id="Height"/>
<parameter id="ImagePrev"/>
<parameter id="Index"/>
<parameter id="RegionCellTrack"/>
<parameter id="RegionUnionPrevRear"/>
<parameter id="Width"/>
<parameter id="path"/>
</parameters>
</docu>
</procedure>
<procedure name="pre_process">
<interface>
<oo>
<par name="ImageOri" base_type="iconic" dimension="0"/>
<par name="ImageGauss" base_type="iconic" dimension="0"/>
<par name="RegionConnected" base_type="iconic" dimension="0"/>
<par name="RegionUnion" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="path" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* 注意 ImageOri是在hdev端调试输出图像用的 在CPP端不需要输出</c>
<l>read_image (ImageOri, path + Index)</l>
<c></c>
<l>get_image_size (ImageOri, Width, Height)</l>
<c></c>
<l>count_channels (ImageOri, Channels)</l>
<l>if(Channels == 3)</l>
<l>    rgb1_to_gray (ImageOri, ImageOri)</l>
<l>endif</l>
<c></c>
<l>gauss_filter (ImageOri, ImageGauss, 7)</l>
<c></c>
<c>* 寻找血管区域 均值滤波+动态阈值</c>
<l>mean_image(ImageGauss, ImageMean, 43, 43)</l>
<l>dyn_threshold(ImageGauss, ImageMean, RegionDynThresh, 5, 'dark')</l>
<c></c>
<c>* 闭运算补小洞</c>
<l>closing_circle(RegionDynThresh, RegionClosing, 3)</l>
<c></c>
<c>* 分散出若干个连接起来的区域 大部分大概率是血管区域</c>
<l>connection(RegionClosing, RawRegionConnected)</l>
<c></c>
<c>* 根据面积筛选掉噪音</c>
<l>select_shape(RawRegionConnected, RegionConnected, 'area', 'and', 50, Width*Height)</l>
<c></c>
<c>* 合并 检测到的分散血管区域 后面有用</c>
<l>union1(RegionConnected, RegionUnion)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="pre_process">
<parameters>
<parameter id="Height"/>
<parameter id="ImageGauss"/>
<parameter id="ImageOri"/>
<parameter id="Index"/>
<parameter id="RegionConnected"/>
<parameter id="RegionUnion"/>
<parameter id="Width"/>
<parameter id="path"/>
</parameters>
</docu>
</procedure>
<procedure name="get_image_sharpness">
<interface>
<oo>
<par name="Image" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Path" base_type="ctrl" dimension="0"/>
<par name="Index" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="Sharpness" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* 预处理函数中使用了均值滤波+动态阈值的方法获取连续的低灰度区域 可认为这些区域都是血管区域</c>
<l>pre_process (Image, ImageGauss, RegionConnected, RegionUnion, Path, Index, Width, Height)</l>
<c></c>
<c>* 血管区域的外轮廓</c>
<l>boundary(RegionUnion, BorderRegionUnion, 'inner')</l>
<c></c>
<c>* 通用方法获取图像边缘区域</c>
<l>equ_histo_image(ImageGauss, ImageGaussEquHisto)</l>
<l>edges_image(ImageGaussEquHisto, ImaAmp, ImaDir, 'canny', 1, 'nms', -1, -1)</l>
<l>mean_image(ImaAmp, ImageMean, 23, 23)</l>
<l>dyn_threshold(ImaAmp, ImageMean, BorderEdges, 5, 'light')</l>
<c></c>
<c>* 计算 血管区域外轮廓的周长 以及 边缘区域长度</c>
<l>area_center(BorderRegionUnion, AreaBorderRegionUnion, useless, useless)</l>
<l>area_center(BorderEdges, AreaBorderEdges, useless, useless)</l>
<c></c>
<c>* 理论上来说 在理想情况下 当一幅图像足够清晰时 其轮廓周长(A)与边缘长度(B)应该相等 即A / B = 1 比如一个线宽为1的黑框白色正方形</c>
<c>* 经过几个数据集实验 此处清晰度取值范围为[0.91, 1.195) </c>
<l>if(|AreaBorderRegionUnion|==1 and |AreaBorderEdges|==1 and AreaBorderRegionUnion&gt;0)</l>
<l>    Sharpness := real(AreaBorderEdges) / real(AreaBorderRegionUnion)</l>
<l>else</l>
<l>    Sharpness := 0</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="get_image_sharpness">
<parameters>
<parameter id="Image"/>
<parameter id="Index"/>
<parameter id="Path"/>
<parameter id="Sharpness"/>
</parameters>
</docu>
</procedure>
<procedure name="split_vessel_region">
<interface>
<io>
<par name="RegionConnected" base_type="iconic" dimension="0"/>
<par name="ImageGauss" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionBranchs" base_type="iconic" dimension="0"/>
<par name="RegionNodes" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<c>* 面积大于4000px的血管区域才进行分割</c>
<l>select_shape(RegionConnected, NeedSplitRegions, 'area', 'and', 4000, Width*Height)</l>
<l>union1(NeedSplitRegions, UnionNeedSplitRegions)</l>
<c></c>
<c>* 求血管区域骨骼(Skeleton)及其分叉点(JuncPoints) 端点(EndPoints)没用</c>
<c>* 注意：骨骼，即中心线</c>
<l>skeleton(UnionNeedSplitRegions, Skeleton)</l>
<l>junctions_skeleton(Skeleton, EndPoints, JuncPoints)</l>
<c></c>
<c>* 分水岭算法 根据连续的灰度等级将需要分割的区域若干块(Basins) 顺便得到分割区域的分割线(Watersheds)</c>
<l>reduce_domain(ImageGauss, UnionNeedSplitRegions, ImageReduced)</l>
<l>equ_histo_image(ImageReduced, ImageEquHisto)</l>
<l>watersheds(ImageEquHisto, Basins, Watersheds)</l>
<c></c>
<c>* 遍历Basins的每个区域块(A) 若A中包含至少一个属于JuncPoints的分叉点(B) 块(block)</c>
<c>* 则认为A属于血管区域的结点区域(Node) 否则属于分支区域(Branch)</c>
<c>* 注意：参考二叉树结构 分为树和子树 再分为结点和叶 此处不叫"叶"叫"分支"比较形象</c>
<l>gen_region_points(UnionRegionBranchBlocks, [], [])</l>
<l>gen_region_points(UnionRegionNodeBlocks, [], [])</l>
<l>count_obj(Basins, Number)</l>
<l>for I := 1 to Number by 1</l>
<l>    select_obj(Basins, ObjectSelected, I)</l>
<l>    intersection(ObjectSelected, JuncPoints, RegionIntersection)</l>
<l>    area_center(RegionIntersection, Area123, useless, useless)</l>
<l>    if(Area123 &lt; 1)</l>
<l>        union2(UnionRegionBranchBlocks, ObjectSelected, UnionRegionBranchBlocks)</l>
<l>    else</l>
<l>        union2(UnionRegionNodeBlocks, ObjectSelected, UnionRegionNodeBlocks)</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<c>* 合并分支区域(Branch)和分割线(Watersheds) 得到完整的原始(Raw)分支区域</c>
<c>* 注意：之所以叫原始区域 是因为这里会有一些依然孤立的或者突兀在分支边缘的分割线 但这里先不处理</c>
<l>union2(UnionRegionBranchBlocks, Watersheds, UnionRegionRawBranchs)</l>
<l>connection(UnionRegionRawBranchs, RegionRawBranchs)</l>
<l>count_obj(RegionRawBranchs, NumberRegionRawBranchs)</l>
<c></c>
<c>* 原始结点区域集合</c>
<l>connection(UnionRegionNodeBlocks, RegionRawNodes)</l>
<l>count_obj(RegionRawNodes, NumbeRegionNodes)</l>
<c></c>
<c>* 需要分割的血管区域的外边界(BorderNeedSplitRegions)</c>
<l>boundary(UnionNeedSplitRegions, BorderNeedSplitRegions, 'inner')</l>
<c></c>
<c>* 以JuncPoints中的各个交叉点为圆点 以JuncPoints中的各个交叉点到BorderNeedSplitRegions的最小距离为半径 作若干个圆(Circles)</c>
<l>get_region_points(JuncPoints, RowsJuncPoints, ColsJuncPoints)</l>
<l>distance_pr(BorderNeedSplitRegions, RowsJuncPoints, ColsJuncPoints, DistanceMin, DistanceMax)</l>
<l>gen_circle(Circles, RowsJuncPoints, ColsJuncPoints, DistanceMin)</l>
<c></c>
<c>* 遍历Circles中的所有圆(A) A的圆点在结点区域内 因此圆A必然和至少1个结点区域(B)相交</c>
<c>* 若A还能与若干个原始分支区域(C)相交 且相交面积达到圆面积的1/10 则可认为B和C是可连接起来的</c>
<c>* 注意：此步骤的理论支撑大概就是 交叉点跟外边界的最小距离内的所有接触区域集合 </c>
<l>gen_region_points(RegionBranchsMergeWithNodes, [], [])</l>
<l>for I:=1 to |RowsJuncPoints| by 1</l>
<l>    select_obj(Circles, Circle, I)</l>
<l>    area_center(Circle, AreaCircle, useless, useless)</l>
<l>    for J:=1 to NumbeRegionNodes by 1</l>
<l>        select_obj(RegionRawNodes, Node, J)</l>
<l>        intersection(Circle, Node, RegionIntersectionCN)</l>
<l>        area_center(RegionIntersectionCN, AreaRegionIntersectionCN, useless, useless)</l>
<l>        if(|AreaRegionIntersectionCN|==1 and AreaRegionIntersectionCN&gt;0)</l>
<l>            for K:=1 to NumberRegionRawBranchs by 1</l>
<l>                select_obj(RegionRawBranchs, RawBranch, K)</l>
<l>                intersection(Circle, RawBranch, RegionIntersectionCB)</l>
<l>                area_center(RegionIntersectionCB, AreaRegionIntersectionCB, useless, useless)</l>
<l>                if(|AreaRegionIntersectionCB|==1 and AreaRegionIntersectionCB&gt;=(AreaCircle/10))</l>
<l>                    union2(RegionBranchsMergeWithNodes, Node, RegionBranchsMergeWithNodes)</l>
<l>                    union2(RegionBranchsMergeWithNodes, RawBranch, RegionBranchsMergeWithNodes)</l>
<l>                endif</l>
<l>            endfor</l>
<l>        endif</l>
<l>    endfor</l>
<l>endfor</l>
<c></c>
<c>* 没有与结点结合的分支</c>
<l>difference(UnionRegionRawBranchs, RegionBranchsMergeWithNodes, RegionNotMergeBranchs)</l>
<c></c>
<c>* 注意 上面说过的孤立或者突兀的分割线 在下述两步中通过区域合并和分割 会十分自然的被处理掉 且可以保证区域的面积从始至终没有改变过</c>
<c></c>
<c>* 最终得到的完整分支区域</c>
<l>connection(RegionBranchsMergeWithNodes, ConnectedBranchsMergeWithNodes)</l>
<l>connection(RegionNotMergeBranchs, ConnectedNotMergeBranchs)</l>
<l>concat_obj(ConnectedBranchsMergeWithNodes, ConnectedNotMergeBranchs, RegionBranchs)</l>
<c></c>
<c>* 最终得到的完整结点区域</c>
<l>union1(RegionBranchs, UnionRegionBranchs)</l>
<l>difference(UnionNeedSplitRegions, UnionRegionBranchs, UnionRegionNodes)</l>
<l>connection(UnionRegionNodes, RegionNodes)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="split_vessel_region">
<parameters>
<parameter id="Height"/>
<parameter id="ImageGauss"/>
<parameter id="RegionBranchs"/>
<parameter id="RegionConnected"/>
<parameter id="RegionNodes"/>
<parameter id="Width"/>
</parameters>
</docu>
</procedure>
</hdevelop>
